// Path: lib/modules/onboarding/bloc/onboarding_bloc.dart

// Author: Dycoh Gacheri (https://github.com/Dycoh)
// Description: BLoC implementation for the onboarding flow. Handles state management
// for user information collection including name, gender, and age. Separates business
// logic from presentation layer for better testability and maintainability.

// Last Modified: Tuesday, 25 February 2025 16:35

// Core/Framework imports
// ignore: unused_import
import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';

// Project imports - Models
import '../models/onboarding_data.dart';

// Events
abstract class OnboardingEvent extends Equatable {
  const OnboardingEvent();
  
  @override
  List<Object?> get props => [];
}

class NameUpdated extends OnboardingEvent {
  final String name;
  
  const NameUpdated(this.name);
  
  @override
  List<Object> get props => [name];
}

class GenderSelected extends OnboardingEvent {
  final String gender;
  
  const GenderSelected(this.gender);
  
  @override
  List<Object> get props => [gender];
}

class AgeUpdated extends OnboardingEvent {
  final double age;
  
  const AgeUpdated(this.age);
  
  @override
  List<Object> get props => [age];
}

class PageChanged extends OnboardingEvent {
  final int pageIndex;
  
  const PageChanged(this.pageIndex);
  
  @override
  List<Object> get props => [pageIndex];
}

class OnboardingSubmitted extends OnboardingEvent {}

// States
abstract class OnboardingState extends Equatable {
  final OnboardingData userData;
  final int currentPage;
  
  const OnboardingState({
    required this.userData,
    required this.currentPage,
  });
  
  @override
  List<Object?> get props => [userData, currentPage];
}

class OnboardingInitial extends OnboardingState {
  const OnboardingInitial()
      : super(userData: const OnboardingData(), currentPage: 0);
}

class OnboardingDataUpdated extends OnboardingState {
  const OnboardingDataUpdated({
    required super.userData,
    required super.currentPage,
  });
}

class OnboardingValidationError extends OnboardingState {
  final String errorMessage;
  final String? fieldName;
  
  const OnboardingValidationError({
    required super.userData,
    required super.currentPage,
    required this.errorMessage,
    this.fieldName,
  });
  
  @override
  List<Object?> get props => [...super.props, errorMessage, fieldName];
}

class OnboardingSubmitSuccess extends OnboardingState {
  const OnboardingSubmitSuccess({
    required super.userData,
  }) : super(currentPage: 2);
}

// BLoC
class OnboardingBloc extends Bloc<OnboardingEvent, OnboardingState> {
  OnboardingBloc() : super(const OnboardingInitial()) {
    on<NameUpdated>(_onNameUpdated);
    on<GenderSelected>(_onGenderSelected);
    on<AgeUpdated>(_onAgeUpdated);
    on<PageChanged>(_onPageChanged);
    on<OnboardingSubmitted>(_onSubmitted);
  }

  // Validates if the user can proceed to the next page
  bool canProceedToNextPage(int currentPage, OnboardingData userData) {
    switch (currentPage) {
      case 0:
        return userData.name != null && userData.name!.isNotEmpty;
      case 1:
        return userData.gender != null;
      case 2:
        return true; // Age always has a default value
      default:
        return false;
    }
  }

  void _onNameUpdated(NameUpdated event, Emitter<OnboardingState> emit) {
    final updatedData = state.userData.copyWith(name: event.name);
    
    emit(OnboardingDataUpdated(
      userData: updatedData,
      currentPage: state.currentPage,
    ));
  }

  void _onGenderSelected(GenderSelected event, Emitter<OnboardingState> emit) {
    final updatedData = state.userData.copyWith(gender: event.gender);
    
    emit(OnboardingDataUpdated(
      userData: updatedData,
      currentPage: state.currentPage,
    ));
  }

  void _onAgeUpdated(AgeUpdated event, Emitter<OnboardingState> emit) {
    final updatedData = state.userData.copyWith(age: event.age);
    
    emit(OnboardingDataUpdated(
      userData: updatedData,
      currentPage: state.currentPage,
    ));
  }

  void _onPageChanged(PageChanged event, Emitter<OnboardingState> emit) {
    // Handle backward navigation logic
    final currentPage = event.pageIndex;
    final previousPage = state.currentPage;
    
    // When navigating backwards, we don't need validation
    if (currentPage < previousPage) {
      emit(OnboardingDataUpdated(
        userData: state.userData,
        currentPage: currentPage,
      ));
      return null; // Add null here instead of empty return
    }
    
    // Validate before proceeding to next page
    if (!canProceedToNextPage(previousPage, state.userData)) {
      String errorMessage;
      String? fieldName;
      
      switch (previousPage) {
        case 0:
          errorMessage = 'Please enter your name';
          fieldName = 'name';
          break;
        case 1:
          errorMessage = 'Please select your gender';
          fieldName = 'gender';
          break;
        default:
          errorMessage = 'Invalid input';
          break;
      }
      
      emit(OnboardingValidationError(
        userData: state.userData,
        currentPage: previousPage,
        errorMessage: errorMessage,
        fieldName: fieldName,
      ));
      return null; // Add null here instead of empty return
    }
    
    // If validation passes, update page
    emit(OnboardingDataUpdated(
      userData: state.userData,
      currentPage: currentPage,
    ));
  }

  void _onSubmitted(OnboardingSubmitted event, Emitter<OnboardingState> emit) {
    // Final validation before submission
    if (!canProceedToNextPage(2, state.userData)) {
      emit(OnboardingValidationError(
        userData: state.userData,
        currentPage: 2,
        errorMessage: 'Please complete all required fields',
        fieldName: null,
      ));
      return null; // Add null here instead of empty return
    }
    
    // If everything is valid, emit success state
    emit(OnboardingSubmitSuccess(userData: state.userData));
    
    // Here you would typically save the data to a repository
    // This could be done by injecting a repository and calling it here
  }
}


// Path: lib/modules/onboarding/models/onboarding_data.dart

// Author: Dycoh Gacheri (https://github.com/Dycoh)
// Description: Data model for user information collected during onboarding.
// Implements value semantics with immutability and equality comparison.

// Last Modified: Tuesday, 25 February 2025 16:35

// Core/Framework imports
import 'package:equatable/equatable.dart';

/// Represents user data collected during the onboarding process
class OnboardingData extends Equatable {
  // Core user information
  final String? name;
  final String? gender;
  final double age;
  
  /// Creates an immutable [OnboardingData] instance
  /// 
  /// Default age is set to 25 as a reasonable starting point
  const OnboardingData({
    this.name,
    this.gender,
    this.age = 25.0,
  });
  
  /// Creates a copy of this [OnboardingData] with the given fields replaced with new values
  OnboardingData copyWith({
    String? name,
    String? gender,
    double? age,
  }) {
    return OnboardingData(
      name: name ?? this.name,
      gender: gender ?? this.gender,
      age: age ?? this.age,
    );
  }
  
  /// Returns whether this instance is complete with all required fields
  bool get isComplete => 
      name != null && 
      name!.isNotEmpty && 
      gender != null;
  
  @override
  List<Object?> get props => [name, gender, age];
  
  @override
  String toString() => 'OnboardingData(name: $name, gender: $gender, age: $age)';
}



// Path: lib/modules/onboarding/screens/onboarding_screen.dart

// Author: Dycoh Gacheri (https://github.com/Dycoh)
// Description: Onboarding screen that guides users through the initial setup process
// with animated GIFs and a multi-page form flow for collecting user information.
// Last Modified: Tuesday, 25 February 2025 16:35

// Core/Framework imports
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

// Project imports - BLoC
import '../bloc/onboarding_bloc.dart';

// Project imports - UI Components
import '../widgets/onboarding_page_view.dart';
import '../widgets/onboarding_gif_view.dart';

// Project imports - Layout
import '../../../app/scaffold.dart';
import '../../../app/theme.dart';
import '../../../app/routes.dart';
import '../../../shared/layout/app_layout.dart';

/// Main onboarding screen that orchestrates the flow and provides BLoC provider
class OnboardingScreen extends StatelessWidget {
  // Asset paths - centralized for easier maintenance
  static const String nameGifPath = 'assets/gifs/onboarding_name_bot.gif';
  static const String genderGifPath = 'assets/gifs/onboarding_gender_bot.gif';
  static const String ageGifPath = 'assets/gifs/onboarding_age_bot.gif';
  
  const OnboardingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => OnboardingBloc(),
      child: _OnboardingView(),
    );
  }
}

/// Private implementation of the onboarding view
class _OnboardingView extends StatefulWidget {
  @override
  State<_OnboardingView> createState() => _OnboardingViewState();
}

class _OnboardingViewState extends State<_OnboardingView> {
  // Controllers for synchronized page transitions
  final PageController _contentPageController = PageController();
  final PageController _gifPageController = PageController();
  
  @override
  void initState() {
    super.initState();
    // Listen for page changes to synchronize animations
    _contentPageController.addListener(_syncGifPageController);
  }
  
  /// Synchronizes the GIF page controller with the content page controller
  /// to ensure animations stay aligned with the current page
  void _syncGifPageController() {
    if (!_contentPageController.hasClients) return;
    
    final currentPage = _contentPageController.page?.round() ?? 0;
    
    // Only animate gif page controller if needed
    if (_gifPageController.hasClients && _gifPageController.page?.round() != currentPage) {
      _gifPageController.animateToPage(
        currentPage,
        duration: const Duration(milliseconds: 150),
        curve: Curves.easeInOut,
      );
    }
    
    // Notify BLoC about page changes
    context.read<OnboardingBloc>().add(PageChanged(currentPage));
  }
  
  @override
  Widget build(BuildContext context) {
    return BlocConsumer<OnboardingBloc, OnboardingState>(
      listenWhen: (previous, current) => 
          current is OnboardingSubmitSuccess ||
          (current is OnboardingValidationError && previous.currentPage != current.currentPage),
      listener: (context, state) {
        if (state is OnboardingSubmitSuccess) {
          // Navigate to post-onboarding screen
          RouteManager.handlePostOnboardingNavigation(context);
        } else if (state is OnboardingValidationError) {
          // Show error snackbar for validation errors that prevent navigation
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(state.errorMessage),
              backgroundColor: AppTheme.kErrorRed,
              behavior: SnackBarBehavior.floating,
            ),
          );
        }
      },
      builder: (context, state) {
        // Handle page sync when state changes page
        if (_contentPageController.hasClients && 
            _contentPageController.page?.round() != state.currentPage) {
          _contentPageController.animateToPage(
            state.currentPage,
            duration: const Duration(milliseconds: 300),
            curve: Curves.easeInOut,
          );
        }
        
        // Create app bar with back button when not on first page
        final PreferredSizeWidget? appBar = state.currentPage > 0 
            ? AppBar(
                backgroundColor: Colors.transparent,
                elevation: 0,
                leading: IconButton(
                  icon: Container(
                    decoration: BoxDecoration(
                      color: AppTheme.kWhite.withOpacity(0.8),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    padding: const EdgeInsets.all(4),
                    child: const Icon(Icons.arrow_back),
                  ),
                  onPressed: () {
                    // Navigate to previous page
                    _contentPageController.previousPage(
                      duration: const Duration(milliseconds: 150),
                      curve: Curves.easeInOut,
                    );
                  },
                ),
              )
            : null;
        
        return AppScaffold(
          currentRoute: 'onboarding',
          showNavigation: false, // Hide navigation during onboarding
          floatingActionButton: null, // Explicitly set to null to prevent layout issues
          layoutType: LayoutType.contentOnly, // Explicitly use contentOnly layout type
          useBackgroundDecorator: true, // Enable background decoration for consistent styling
          contentWidthFraction: 0.95, // Increased from 0.9 to use more screen space and reduce scrolling
          contentPadding: EdgeInsets.symmetric(
            horizontal: AppTheme.kSpacing3x, // Reduced from 4x to 3x
            vertical: AppTheme.kSpacing, // Reduced from 2x to 1x to minimize vertical space usage
          ),
          appBar: appBar, // Add the dynamic app bar
          body: _buildResponsiveLayout(context, state.currentPage),
        );
      },
    );
  }
  
  /// Main responsive layout builder function that switches between wide and narrow layouts
  /// based on the available screen width
  Widget _buildResponsiveLayout(BuildContext context, int currentPage) {
    // Use a LayoutBuilder to determine the available screen space
    return LayoutBuilder(
      builder: (context, constraints) {
        final isWideScreen = constraints.maxWidth > 800;
        
        if (isWideScreen) {
          return _buildWideLayout(constraints, currentPage);
        } else {
          return _buildNarrowLayout(constraints, currentPage);
        }
      },
    );
  }
  
  /// Layout for wider screens (tablets, desktops) with side-by-side content
  Widget _buildWideLayout(BoxConstraints constraints, int currentPage) {
    // Ensure we have finite constraints by using explicit sizing
    final screenSize = MediaQuery.of(context).size;
    
    return Container(
      width: screenSize.width,
      height: screenSize.height,
      // Use a Row for horizontal layout on wide screens
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          // GIF section (left side) without progress indicator
          Expanded(
            flex: 6,
            child: Center(
              child: SizedBox(
                height: screenSize.height * 0.7, // Fixed percentage of screen height
                width: constraints.maxWidth * 0.4,
                child: OnboardingGifView(
                  pageController: _gifPageController,
                  gifPaths: [
                    OnboardingScreen.nameGifPath,
                    OnboardingScreen.genderGifPath,
                    OnboardingScreen.ageGifPath,
                  ],
                ),
              ),
            ),
          ),
          
          // Content section (right side)
          Expanded(
            flex: 6,
            child: Padding(
              padding: EdgeInsets.symmetric(
                horizontal: AppTheme.kSpacing4x, // Reduced from 6x to 4x
                vertical: AppTheme.kSpacing, // Reduced from 2x to 1x
              ),
              child: Center(
                child: SizedBox(
                  height: screenSize.height * 0.65, // Increased from 0.6 to 0.65 for more content space
                  width: constraints.maxWidth * 0.45, // Increased from 0.4 to 0.45 for more content space
                  child: _buildContentSection(currentPage),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  /// Layout for narrower screens (phones) with vertically stacked content
  /// Fixed to prevent infinite height constraints in SingleChildScrollView
  Widget _buildNarrowLayout(BoxConstraints constraints, int currentPage) {
    // Calculate fixed heights based on device screen size instead of unbounded constraints
    // This prevents the "BoxConstraints forces an infinite height" error
    final double gifHeight = MediaQuery.of(context).size.height * 0.28; // Reduced from 0.3 to 0.28
    final double contentHeight = MediaQuery.of(context).size.height * 0.55; // Increased from 0.5 to 0.55
    
    return SingleChildScrollView(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          SizedBox(height: AppTheme.kSpacing), // Reduced from 2x to 1x
          
          // GIF section (top) without progress indicator
          SizedBox(
            height: gifHeight,
            width: constraints.maxWidth * 0.95, // Increased from 0.9 to 0.95
            child: OnboardingGifView(
              pageController: _gifPageController,
              gifPaths: [
                OnboardingScreen.nameGifPath,
                OnboardingScreen.genderGifPath,
                OnboardingScreen.ageGifPath,
              ],
            ),
          ),
          
          SizedBox(height: AppTheme.kSpacing), // Reduced from 2x to 1x
          
          // Content section (bottom)
          SizedBox(
            height: contentHeight,
            width: constraints.maxWidth * 0.95, // Increased from 0.9 to 0.95
            child: _buildContentSection(currentPage),
          ),
          
          // Reduced bottom padding
          SizedBox(height: AppTheme.kSpacing2x), // Reduced from 4x to 2x
        ],
      ),
    );
  }
  
  /// Content section containing the page view with progress indicator
  Widget _buildContentSection(int currentPage) {
    return OnboardingPageView(
      pageController: _contentPageController,
      currentPage: currentPage,
      onSubmit: () {
        context.read<OnboardingBloc>().add(OnboardingSubmitted());
      },
    );
  }
  
  @override
  void dispose() {
    _contentPageController.removeListener(_syncGifPageController);
    _contentPageController.dispose();
    _gifPageController.dispose();
    super.dispose();
  }
}


// Path: lib/modules/onboarding/widgets/onboarding_page_view.dart

// Author: Dycoh Gacheri (https://github.com/Dycoh)
// Description: Page view component for onboarding screens. Contains pages for
// name input, gender selection, and age selection with appropriate input widgets
// and validation.

// Last Modified: Tuesday, 25 February 2025 16:35

// Core/Framework imports
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

// Project imports - BLoC
import '../bloc/onboarding_bloc.dart';

// Project imports - Components
import 'onboarding_input_widgets.dart';

// Project imports - Theme
import '../../../app/theme.dart';

/// Widget that manages the content pages for the onboarding flow
class OnboardingPageView extends StatelessWidget {
  // Controllers and callbacks
  final PageController pageController;
  final VoidCallback onSubmit;
  
  // Page titles and subtitles
  static const List<Map<String, String>> _pageContent = [
    {
      'title': 'What\'s your name?',
      'subtitle': 'So I can greet you properly each time we meet, what name would you prefer?',
      'buttonText': 'Continue',
    },
    {
      'title': 'What\'s your\nGender?',
      'subtitle': 'This information helps me provide more relevant content based on mental health patterns across different groups.',
      'buttonText': 'Continue',
    },
    {
      'title': 'What\'s your\nAge?',
      'subtitle': 'Understanding your life stage helps me tailor suggestions that resonate with your experiences.',
      'buttonText': 'Sign in',
    },
  ];

  const OnboardingPageView({
    super.key,
    required this.pageController,
    required this.onSubmit,
  });

  @override
  Widget build(BuildContext context) {
    return PageView.builder(
      controller: pageController,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: 3,
      itemBuilder: (context, index) {
        return SingleChildScrollView(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Page title
              Text(
                _pageContent[index]['title']!,
                style: Theme.of(context).textTheme.displayLarge?.copyWith(
                  color: AppTheme.kTextBrown,
                  fontWeight: FontWeight.w800,
                  fontSize: 48,
                ),
                textAlign: TextAlign.left,
              ),
              SizedBox(height: AppTheme.kSpacing2x),
              
              // Decorative line
              Container(
                width: 180,
                height: 3,
                decoration: BoxDecoration(
                  color: AppTheme.kPrimaryGreen.withOpacity(0.5),
                  borderRadius: BorderRadius.circular(1.5),
                ),
              ),
              SizedBox(height: AppTheme.kSpacing3x),
              
              // Page subtitle
              Text(
                _pageContent[index]['subtitle']!,
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                  color: AppTheme.kTextBrown,
                  fontWeight: FontWeight.w300,
                  fontSize: 16,
                ),
                textAlign: TextAlign.left,
              ),
              SizedBox(height: AppTheme.kSpacing3x),
              
              // Page-specific input widget
              SizedBox(
                width: double.infinity,
                child: _buildInputWidget(context, index),
              ),
              SizedBox(height: AppTheme.kSpacing4x),
              
              // Navigation button
              _buildNavigationButton(context, index),
              SizedBox(height: AppTheme.kSpacing6x),
            ],
          ),
        );
      },
    );
  }

  // Builds the appropriate input widget based on page index
  Widget _buildInputWidget(BuildContext context, int index) {
    return BlocBuilder<OnboardingBloc, OnboardingState>(
      builder: (context, state) {
        switch (index) {
          case 0:
            return NameInputField(
              initialValue: state.userData.name,
              showError: state is OnboardingValidationError && state.fieldName == 'name',
              onChanged: (value) {
                context.read<OnboardingBloc>().add(NameUpdated(value));
              },
            );
          case 1:
            return GenderSelector(
              selectedGender: state.userData.gender,
              onGenderChanged: (gender) {
                context.read<OnboardingBloc>().add(GenderSelected(gender));
              },
            );
          case 2:
            return AgeSelector(
              selectedAge: state.userData.age,
              onAgeChanged: (age) {
                context.read<OnboardingBloc>().add(AgeUpdated(age));
              },
            );
          default:
            return const SizedBox.shrink();
        }
      },
    );
  }

  // Builds the navigation button with appropriate text
  Widget _buildNavigationButton(BuildContext context, int index) {
    return BlocBuilder<OnboardingBloc, OnboardingState>(
      builder: (context, state) {
        final bool isLastPage = index == 2;
        final String buttonText = _pageContent[index]['buttonText']!;
        
        return Align(
          alignment: Alignment.centerLeft,
          child: ElevatedButton(
            onPressed: () => _handleNavigation(context, index, isLastPage),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppTheme.kAccentBrown,
              foregroundColor: AppTheme.kWhite,
              padding: EdgeInsets.symmetric(
                horizontal: AppTheme.kSpacing4x,
                vertical: AppTheme.kSpacing2x,
              ),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(50.0),
              ),
            ),
            child: Padding(
              padding: const EdgeInsets.symmetric(
                horizontal: AppTheme.kSpacing,
                vertical: AppTheme.kSpacing,
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(buttonText),
                  const SizedBox(width: 8),
                  const Icon(Icons.arrow_forward, size: 18, color: AppTheme.kWhite),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  // Handles navigation based on current page and validation
  void _handleNavigation(BuildContext context, int currentIndex, bool isLastPage) {
    final bloc = context.read<OnboardingBloc>();
    
    // Validate if we can proceed to the next page
    if (bloc.canProceedToNextPage(currentIndex, bloc.state.userData)) {
      if (isLastPage) {
        // Submit if on last page
        onSubmit();
      } else {
        // Navigate to next page
        pageController.nextPage(
          duration: const Duration(milliseconds: 150),
          curve: Curves.easeInOut,
        );
      }
    } else {
      // Trigger validation error
      String errorMessage;
      String? fieldName;
      
      switch (currentIndex) {
        case 0:
          errorMessage = 'Please enter your name';
          fieldName = 'name';
          break;
        case 1:
          errorMessage = 'Please select your gender';
          fieldName = 'gender';
          break;
        default:
          errorMessage = 'Invalid input';
          break;
      }
      
      bloc.add(PageChanged(currentIndex)); // This will trigger validation in the bloc
    }
  }
}


// Path: lib/modules/onboarding/widgets/onboarding_input_widgets.dart

// Core/Framework imports
import 'package:flutter/material.dart';

// Project imports - Theme
import '../../../app/theme.dart';

/// Name input field with validation
class NameInputField extends StatefulWidget {
  final String? initialValue;
  final bool showError;
  final ValueChanged<String> onChanged;

  const NameInputField({
    super.key,
    this.initialValue,
    this.showError = false,
    required this.onChanged,
  });

  @override
  State<NameInputField> createState() => _NameInputFieldState();
}

class _NameInputFieldState extends State<NameInputField> {
  late final TextEditingController _controller;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.initialValue);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        TextField(
          controller: _controller,
          onChanged: widget.onChanged,
          decoration: InputDecoration(
            hintText: 'Enter your name',
            border: widget.showError
                ? OutlineInputBorder(
                    borderRadius: BorderRadius.circular(30.0),
                    borderSide: const BorderSide(color: Colors.red),
                  )
                : OutlineInputBorder(
                    borderRadius: BorderRadius.circular(30.0),
                    borderSide: BorderSide.none,
                  ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(30.0),
              borderSide: const BorderSide(color: AppTheme.kPrimaryGreen),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(30.0),
              borderSide: const BorderSide(color: AppTheme.kGray200),
            ),
            filled: true,
            fillColor: AppTheme.kWhite,
            contentPadding: const EdgeInsets.all(AppTheme.kSpacing2x),
            errorBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(30.0),
              borderSide: const BorderSide(color: Colors.red),
            ),
            // Add shadow to input field
            prefixIcon: const Padding(
              padding: EdgeInsets.only(left: 12.0, right: 8.0),
              child: Icon(Icons.person_outline, color: AppTheme.kPrimaryGreen),
            ),
          ),
          style: const TextStyle(
            color: AppTheme.kTextBrown,
            fontSize: 16,
          ),
        ),
        if (widget.showError) ...[
          SizedBox(height: AppTheme.kSpacing),
          const Text(
            'Please enter your name',
            style: TextStyle(
              color: Colors.red,
              fontSize: 12,
            ),
          ),
        ],
      ],
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}

/// Gender selection widget with animated button states
class GenderSelector extends StatelessWidget {
  final String? selectedGender;
  final ValueChanged<String> onGenderChanged;

  const GenderSelector({
    super.key,
    this.selectedGender,
    required this.onGenderChanged,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        // Determine if we should use a vertical layout based on width
        final bool useVerticalLayout = constraints.maxWidth < 350;
        
        if (useVerticalLayout) {
          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              _GenderButton(
                label: 'Male',
                isSelected: selectedGender == 'Male',
                isEnabled: selectedGender == null || selectedGender == 'Male',
                onTap: () => onGenderChanged('Male'),
                icon: Icons.male,
              ),
              SizedBox(height: AppTheme.kSpacing2x),
              _GenderButton(
                label: 'Female',
                isSelected: selectedGender == 'Female',
                isEnabled: selectedGender == null || selectedGender == 'Female',
                onTap: () => onGenderChanged('Female'),
                icon: Icons.female,
              ),
              SizedBox(height: AppTheme.kSpacing2x),
              _GenderButton(
                label: 'Other',
                isSelected: selectedGender == 'Other',
                isEnabled: selectedGender == null || selectedGender == 'Other',
                onTap: () => onGenderChanged('Other'),
                icon: Icons.person,
              ),
            ],
          );
        } else {
          return Row(
            mainAxisAlignment: MainAxisAlignment.start,
            children: [
              Expanded(
                child: _GenderButton(
                  label: 'Male',
                  isSelected: selectedGender == 'Male',
                  isEnabled: selectedGender == null || selectedGender == 'Male',
                  onTap: () => onGenderChanged('Male'),
                  icon: Icons.male,
                ),
              ),
              SizedBox(width: AppTheme.kSpacing2x),
              Expanded(
                child: _GenderButton(
                  label: 'Female',
                  isSelected: selectedGender == 'Female',
                  isEnabled: selectedGender == null || selectedGender == 'Female',
                  onTap: () => onGenderChanged('Female'),
                  icon: Icons.female,
                ),
              ),
              SizedBox(width: AppTheme.kSpacing2x),
              Expanded(
                child: _GenderButton(
                  label: 'Other',
                  isSelected: selectedGender == 'Other',
                  isEnabled: selectedGender == null || selectedGender == 'Other',
                  onTap: () => onGenderChanged('Other'),
                  icon: Icons.person,
                ),
              ),
            ],
          );
        }
      }
    );
  }
}

/// Animated button for gender selection
class _GenderButton extends StatelessWidget {
  final String label;
  final bool isSelected;
  final bool isEnabled;
  final VoidCallback onTap;
  final IconData icon;

  const _GenderButton({
    required this.label,
    required this.isSelected,
    required this.isEnabled,
    required this.onTap,
    required this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: isEnabled ? onTap : null,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        padding: EdgeInsets.symmetric(
          horizontal: AppTheme.kSpacing2x,
          vertical: AppTheme.kSpacing2x,
        ),
        decoration: BoxDecoration(
          color: isSelected
              ? AppTheme.kPrimaryGreen
              : isEnabled
                  ? AppTheme.kWhite
                  : AppTheme.kGray100,
          borderRadius: BorderRadius.circular(30),
          border: Border.all(
            color: isSelected
                ? AppTheme.kPrimaryGreen
                : isEnabled
                    ? AppTheme.kGray200
                    : AppTheme.kGray100,
            width: 1,
          ),
          boxShadow: isSelected
              ? [
                  BoxShadow(
                    color: AppTheme.kPrimaryGreen.withOpacity(0.4),
                    blurRadius: 8,
                    offset: const Offset(0, 2),
                  ),
                ]
              : [],
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              color: isSelected
                  ? AppTheme.kWhite
                  : isEnabled
                      ? AppTheme.kPrimaryGreen
                      : AppTheme.kGray400,
              size: 20,
            ),
            SizedBox(width: AppTheme.kSpacing),
            Text(
              label,
              style: TextStyle(
                color: isSelected
                    ? AppTheme.kWhite
                    : isEnabled
                        ? AppTheme.kTextBrown
                        : AppTheme.kGray400,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Age selector with slider and numeric display
class AgeSelector extends StatelessWidget {
  final double selectedAge;
  final ValueChanged<double> onAgeChanged;

  const AgeSelector({
    super.key,
    required this.selectedAge,
    required this.onAgeChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Age display with card background
        Container(
          padding: EdgeInsets.all(AppTheme.kSpacing2x),
          decoration: BoxDecoration(
            color: AppTheme.kWhite,
            borderRadius: BorderRadius.circular(16),
            boxShadow: [
              BoxShadow(
                color: AppTheme.kGray200.withOpacity(0.5),
                blurRadius: 10,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                selectedAge.toInt().toString(),
                style: TextStyle(
                  color: AppTheme.kPrimaryGreen,
                  fontSize: 48,
                  fontWeight: FontWeight.bold,
                ),
              ),
              SizedBox(width: AppTheme.kSpacing),
              Text(
                'years',
                style: TextStyle(
                  color: AppTheme.kTextBrown,
                  fontSize: 16,
                ),
              ),
            ],
          ),
        ),
        SizedBox(height: AppTheme.kSpacing3x),
        
        // Age slider with custom theme
        SliderTheme(
          data: SliderThemeData(
            activeTrackColor: AppTheme.kPrimaryGreen,
            inactiveTrackColor: AppTheme.kGray100,
            thumbColor: AppTheme.kWhite,
            thumbShape: RoundSliderThumbShape(
              enabledThumbRadius: 15,
              elevation: 4,
            ),
            overlayColor: AppTheme.kPrimaryGreen.withOpacity(0.2),
            trackHeight: 8,
          ),
          child: Slider(
            value: selectedAge,
            min: 13.0, // Minimum age
            max: 100.0, // Maximum age
            divisions: 87, // (max - min)
            onChanged: onAgeChanged,
          ),
        ),
        
        // Min and max labels with improved styling
        Padding(
          padding: EdgeInsets.symmetric(horizontal: AppTheme.kSpacing),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Container(
                padding: EdgeInsets.symmetric(
                  horizontal: AppTheme.kSpacing,
                  vertical: AppTheme.kSpacing / 2,
                ),
                decoration: BoxDecoration(
                  color: AppTheme.kGray100,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '13',
                  style: TextStyle(
                    color: AppTheme.kGray600,
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              Container(
                padding: EdgeInsets.symmetric(
                  horizontal: AppTheme.kSpacing,
                  vertical: AppTheme.kSpacing / 2,
                ),
                decoration: BoxDecoration(
                  color: AppTheme.kGray100,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '100',
                  style: TextStyle(
                    color: AppTheme.kGray600,
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}


// Path: lib/modules/onboarding/widgets/onboarding_gif_view.dart

// Author: Dycoh Gacheri (https://github.com/Dycoh)
// Description: Widget for displaying animated GIFs that correspond to each page of the onboarding flow.
// Handles proper transitions, error states, and visual styling for a smooth user experience.

// Last Modified: Tuesday, 25 February 2025 16:35

// Core/Framework imports
import 'package:flutter/material.dart';

// Project imports - Theme
import '../../../app/theme.dart';

/// Widget for displaying animated GIFs that correspond to each page of the onboarding flow
class OnboardingGifView extends StatelessWidget {
  // Controllers and assets
  final PageController pageController;
  final List<String> gifPaths;
 
  /// Creates an [OnboardingGifView] for displaying animated GIFs during onboarding
  ///
  /// [pageController] should be synchronized with the main content page controller
  /// [gifPaths] is a list of asset paths for the GIFs corresponding to each page
  const OnboardingGifView({
    super.key,
    required this.pageController,
    required this.gifPaths,
  }) : assert(gifPaths.length > 0, 'Must provide at least one GIF path');
  
  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        // Using light green container for background instead of yellow
        color: AppTheme.kLightGreenContainer,
        borderRadius: BorderRadius.circular(AppTheme.kRadiusLarge),
        boxShadow: [
          BoxShadow(
            color: AppTheme.kGray300.withOpacity(0.3),
            blurRadius: 15,
            spreadRadius: 2,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(AppTheme.kRadiusLarge),
        child: Stack(
          children: [
            // Page view with GIFs
            PageView.builder(
              controller: pageController,
              physics: const NeverScrollableScrollPhysics(), // Don't allow manual swiping
              itemCount: gifPaths.length,
              itemBuilder: (context, index) {
                return _buildGifContainer(gifPaths[index]);
              },
            ),
           
            // Decorative elements
            Positioned(
              top: 0,
              left: 0,
              right: 0,
              child: Container(
                height: 10,
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [
                      AppTheme.kPrimaryGreen.withOpacity(0.2),
                      AppTheme.kPrimaryGreen.withOpacity(0.0),
                    ],
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  // Builds the container for an individual GIF with proper styling
  Widget _buildGifContainer(String gifPath) {
    return Container(
      decoration: BoxDecoration(
        // Using light green container for background instead of yellow
        color: AppTheme.kLightGreenContainer,
      ),
      child: Center(
        child: Image.asset(
          gifPath,
          fit: BoxFit.contain,
          // Adding a fade-in animation for smoother transitions
          frameBuilder: (BuildContext context, Widget child, int? frame, bool wasSynchronouslyLoaded) {
            if (wasSynchronouslyLoaded) {
              return child;
            }
            return AnimatedOpacity(
              opacity: frame == null ? 0 : 1,
              duration: const Duration(milliseconds: 300),
              curve: Curves.easeOut,
              child: child,
            );
          },
          // Error handling for missing assets
          errorBuilder: (context, error, stackTrace) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.image_not_supported_outlined,
                    size: 48,
                    color: AppTheme.kGray400,
                  ),
                  SizedBox(height: AppTheme.kSpacing),
                  Text(
                    'Image not available',
                    style: TextStyle(
                      color: AppTheme.kGray400,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            );
          },
        ),
      ),
    );
  }
}